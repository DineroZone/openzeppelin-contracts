= GSN Bouncers

This guide shows you different strategies to accept transactions via the Gas Station Network (GSN) using GSN Bouncers.

First, we will explain the Bouncer concept, and then we will showcase how to use the two most common strategies.
Finally, we will cover how to create your own Custom Bouncer.

If you're still learning about the basics of the Gas Station Network, you should first head over to the xref:gsn.adoc[GSN Guide].

[[gsn-bouncers]]
== GSN Bouncers explained

A *GSN Bouncer* decides which transaction gets approved and which transaction gets rejected. Bouncers are a key concept within the GSN. Dapps need Bouncers to prevent malicious users from spending the dapp's funds for transaction fees.

As we have seen in the xref:gsn.adoc[GSN Guide], in order to be GSN enabled, your contracts need to extend from xref:api:gsn.adoc#GSNRecipient[`GSNRecipient`].

A GSN recipient contract needs the following to work:

1. It needs to have funds deposited on its RelayHub.
2. It needs to handle `msg.sender` and `msg.data` differently
3. It needs to decide how to approve and reject transactions.

Depositing funds for the GSN recipient contract can be done via the https://gsn.openzeppelin.com/recipients[GSN Dapp tool] or programmatically with https://github.com/OpenZeppelin/openzeppelin-gsn-helpers#usage-from-code[OpenZeppelin GSN Helpers].

The actual user's `msg.sender` and `msg.data` can be obtained safely via `_msgSender()` and `_msgData()` of https://docs.openzeppelin.com/contracts/2.x/api/gsn#GSNRecipient[`GSNRecipient`].

Deciding how to approve and reject transactions is a bit more complex. The GSN recipient contract, with the simplest implementation, will accept and pay for all transactions. Chances are you probably want to choose which users can use your contracts via the GSN and potentially charge them for it, like a bouncer at a nightclub. We call these contracts _GSN Bouncers_.

In this guide we describe how to use the included bouncers xref:api:gsn.adoc#GSNBouncerSignature[`GSNBouncerSignature`] and xref:api:gsn.adoc#GSNBouncerERC20Fee[`GSNBouncerERC20Fee`], along with how to create your own Custom Bouncer.

== GSNBouncerSignature

The https://docs.openzeppelin.com/contracts/2.x/api/gsn#GSNBouncerSignature[`GSNBouncerSignature`] lets users call your recipient contract via the GSN (charging you for it) if they can prove that an account you trust approved them to do so. The way they do this is via a _signature_.

The transaction request must include a signature by the same account that was added to the contract as a trusted signer. If it is not the same, the `GSNBouncerSignature` will not accept the transaction.

This means that you need to set up a system where your trusted account includes their signature with transaction requests, as long as they are valid users (according to your business logic).

The definition of a valid user depends on your system, but an example is users that have completed their sign up via some kind of https://en.wikipedia.org/wiki/OAuth[OAuth] and validation, e.g. gone through a captcha or validated their email address.
You could restrict it further and let new users send a specific number of transactions (e.g. limit to 5 requests via the GSN, at which point the user needs to create a wallet).
Alternatively, you could charge the user off-chain (e.g. via credit card) for credit on your system and let them create GSN transactions until their credit runs out.

The great thing about this setup is that *your contract doesn't need to change* if you want to change the business rules. All you are doing is changing the backend logic conditions under which users use your contract for free.
On the other hand, you need to have a backend server, microservice, or lambda function to accomplish this.

=== How does GSNBouncerSignature work?

The `GSNBouncerSignature` decides whether or not to accept the transaction based on the included signature. No further GSN actions need to be taken.  The `acceptRelayedCall` function only relies on the `approvalData`.  The definition of `acceptRelayedCall` function from `GSNBouncerSignature` is below:  

[source,solidity]
----
function acceptRelayedCall(
    address relay,
    address from,
    bytes calldata encodedFunction,
    uint256 transactionFee,
    uint256 gasPrice,
    uint256 gasLimit,
    uint256 nonce,
    bytes calldata approvalData,
    uint256
)
    external
    view
    returns (uint256, bytes memory)
{
    bytes memory blob = abi.encodePacked(
        relay,
        from,
        encodedFunction,
        transactionFee,
        gasPrice,
        gasLimit,
        nonce, // Prevents replays on RelayHub
        getHubAddr(), // Prevents replays in multiple RelayHubs
        address(this) // Prevents replays in multiple recipients
    );
    if (keccak256(blob).toEthSignedMessageHash().recover(approvalData) == _trustedSigner) {
        return _approveRelayedCall();
    } else {
        return _rejectRelayedCall(uint256(GSNBouncerSignatureErrorCodes.INVALID_SIGNER));
    }
}
----

==== Approve/Reject

When the included signature matches the trusted signer, the function returns the following:

[source,solidity]
----
return _approveRelayedCall();

// Defined on base class GSNBouncerBase
// uint256 constant private RELAYED_CALL_ACCEPTED = 0;
// function _approveRelayedCall(bytes memory context) internal pure returns (uint256, bytes memory) {
//     return (RELAYED_CALL_ACCEPTED, context);
// }
----

On the other hand, when the included signature doesn't match the trusted signer, the call gets rejected with the following:

[source,solidity]
----
return _rejectRelayedCall(uint256(GSNBouncerSignatureErrorCodes.INVALID_SIGNER));

// Defined on base class GSNBouncerBase
// uint256 constant private RELAYED_CALL_REJECTED = 11;
// function _rejectRelayedCall(uint256 errorCode) internal pure returns (uint256, bytes memory) {
//     return (RELAYED_CALL_REJECTED + errorCode, "");
// }
----

=== How to use GSNBouncerSignature

You will need to create an off-chain service (e.g. backend server, microservice, or lambda function) that your dapp calls when requesting a GSN transaction, which includes (or doesn't include) their signature with each transaction request based on your business logic.

Your GSN recipient contract needs to inherit from `GSNRecipient` and `GSNBouncerSignature`, as well as setting the trusted signer in the constructor of `GSNBouncerSignature` as per the following sample code below:

[source,solidity]
----
contract MyContract is GSNRecipient, GSNBouncerSignature {
    constructor(address trustedSigner) public GSNBouncerSignature(trustedSigner) {
    }
}  
----

== GSNBouncerERC20Fee

The https://docs.openzeppelin.com/contracts/2.x/api/gsn#GSNBouncerERC20Fee[`GSNBouncerERC20Fee`] is a bit more complex (but don't worry, it has already been written for you!). Unlike `GSNBouncerSignature`, the `GSNBouncerERC20Fee` doesn't require any off-chain services.
Instead of off-chain approving each transaction, you will give contract specific ERC20 tokens to your users. These tokens are then used as payment for GSN transactions to your recipient contract.
Any user that has enough tokens is automatically approved and the recipient contract will cover their transaction costs!

This bouncer charges users for the ether cost your recipient contract will incur. Each recipient contract has their own unique token, with a baked-in exchange rate of 1:1 to ether, since they act as an ether replacement when using the GSN.

The `GSNBouncerERC20Fee` has an internal https://docs.openzeppelin.com/contracts/2.x/api/gsn#GSNBouncerERC20Fee-_mint-address-uint256-[`_mint`] function. Firstly, you need to setup a way to call it (e.g. add a public function with some form of xref:access-control.adoc[access control] such as https://docs.openzeppelin.com/contracts/2.x/api/access#MinterRole-onlyMinter--[`onlyMinter`]).
Then, issue tokens to users based on your business logic. For example, you could mint a limited amount of tokens to new users, mint tokens when users buy them off-chain, give tokens based on a users subscription, etc.

NOTE: *Users do not need to call approve* on their tokens for your recipient contract to use them. They are a modified ERC20 variant that lets the recipient contract retrieve them.

=== How does GSNBouncerERC20Fee work?

The `GSNBouncerERC20Fee` decides to approve or reject transactions based on the balance of the users tokens.  The definition of `acceptRelayedCall` function from `GSNBouncerERC20Fee` is below: 

[source,solidity]
----
function acceptRelayedCall(
    address,
    address from,
    bytes calldata,
    uint256 transactionFee,
    uint256 gasPrice,
    uint256,
    uint256,
    bytes calldata,
    uint256 maxPossibleCharge
)
    external
    view
    returns (uint256, bytes memory)
{
    if (_token.balanceOf(from) < maxPossibleCharge) {
        return _rejectRelayedCall(uint256(GSNBouncerERC20FeeErrorCodes.INSUFFICIENT_BALANCE));
    }

    return _approveRelayedCall(abi.encode(from, maxPossibleCharge, transactionFee, gasPrice));
}
----

==== Approve/Reject

The `GSNBouncerERC20Fee` rejects the transaction if the user doesn't have enough tokens.
If the user has the required amount of tokens, `GSNBouncerERC20Fee` approves the transaction and returns `_approveRelayedCall` to make that data available to `_preRelayedCall` and `_postRelayedCall`.

==== Token transfer

Now, let's see how the token transfer is performed inside the `_preRelayedCall` function.

[source,solidity]
----
function _preRelayedCall(bytes memory context) internal returns (bytes32) {
    (address from, uint256 maxPossibleCharge) = abi.decode(context, (address, uint256));

    // The maximum token charge is pre-charged from the user
    _token.safeTransferFrom(from, address(this), maxPossibleCharge);
}
----

The maximum amount of tokens required is transferred assuming that the call will use all the gas available.
Then, in the `_postRelayedCall` function, the actual amount is calculated - including the recipient contract implementation and ERC20 token transfers - and refund the difference.

[source,solidity]
----
function _postRelayedCall(bytes memory context, bool, uint256 actualCharge, bytes32) internal {
    (address from, uint256 maxPossibleCharge, uint256 transactionFee, uint256 gasPrice) =
        abi.decode(context, (address, uint256, uint256, uint256));

    // actualCharge is an _estimated_ charge, which assumes postRelayedCall will use all available gas.
    // This implementation's gas cost can be roughly estimated as 10k gas, for the two SSTORE operations in an
    // ERC20 transfer.
    uint256 overestimation = _computeCharge(POST_RELAYED_CALL_MAX_GAS.sub(10000), gasPrice, transactionFee);
    actualCharge = actualCharge.sub(overestimation);

    // After the relayed call has been executed and the actual charge estimated, the excess pre-charge is returned
    _token.safeTransfer(from, maxPossibleCharge.sub(actualCharge));
}
----

The maximum amount of tokens required is transferred to protect the contract from exploits (this is really similar to how ether is locked in Ethereum transactions).

NOTE: The gas cost estimation is not 100% accurate, we may tweak it further down the road.

NOTE: Internal `_preRelayedCall` and `_postRelayedCall` functions are used instead of public `preRelayedCall` and `postRelayedCall` functions. This prevents them from being called by non-RelayHub contracts. 
Always use `_preRelayedCall` and `_postRelayedCall` functions.

=== How to use GSNBouncerERC20Fee

Your GSN recipient contract needs to inherit from `GSNRecipient` and `GSNBouncerERC20Fee` along with appropriate xref:access-control.adoc[access control] (for token minting), set the token details in the constructor of `GSNBouncerERC20Fee` and create a public `mint` function suitably protected by your chosen access control as per the following sample code (which uses the https://docs.openzeppelin.com/contracts/2.x/api/access#MinterRole[MinterRole]):

NOTE: The token must have decimals of 18 to match that of ether, due to the baked-in exchange rate of 1:1.

[source,solidity]
----
contract MyContract is GSNRecipient, GSNBouncerERC20Fee, MinterRole {
    constructor() public GSNBouncerERC20Fee("FeeToken", "FEE", 18) {
    }

    function mint(address account, uint256 amount) public onlyMinter {
        _mint(account, amount);
    }
}
----

== Custom Bouncer

You can create your own Custom Bouncer!  For example, your Custom Bouncer could use a specified token to pay for transactions with a custom exchange rate to ether.  Alternatively you could issue users who subscribe to your dapp ERC721 tokens and accounts holding the subscription token could use your contract for free as part of the subscription.  There are lots of potential options for your Custom Bouncer.

Your Custom Bouncer can inherit from `GSNBouncerBase` and must implement the `acceptRelayedCall` function.

Depending on the logic for your Custom Bouncer, you may need to implement `_postRelayedCall` and `_preRelayedCall`.

Your GSN recipient contract needs to inherit from `GSNRecipient` and your Custom Bouncer as per the following sample code:

[source,solidity]
----
contract MyContract is GSNRecipient, MyCustomBouncer {
    constructor() public MyCustomBouncer() {
    }
}
