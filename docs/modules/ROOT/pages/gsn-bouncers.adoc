= GSN Bouncers

This guide shows you different strategies to accept transactions via Gas Station Network using GSN Bouncers.

First, we will explain the Bouncer concept, and then we will showcase how to use the two most common strategies.
Finally, we will cover how to create your own custom Bouncer.

If you're still learning about the basics of the Gas Station Network, you should head over to the xref:gsn.adoc[GSN Guide].

[[gsn-bouncers]]
== GSN Bouncers explained

A *GSN Bouncer* decides which transaction gets approved and which transaction gets rejected. Bouncers are a key concept within the GSN. Dapps need Bouncers to prevent malicious users from spending the dapps transaction fee subsidies.

As we have seen in the xref:gsn.adoc[GSN Guide], in order to be GSN enabled, your contracts need to extend from `GSNRecipient`.

A GSN recipient contract needs the following to work:

1. It needs to have funds deposited on its RelayHub.
2. It needs to handle `msg.sender` and `msg.data` differently
3. It needs to decide how to approve and reject transactions.

Depositing funds can be done via the https://gsn.openzeppelin.com/recipients[GSN Dapp tool] or programmatically with https://github.com/OpenZeppelin/openzeppelin-gsn-helpers#usage-from-code[OpenZeppelin GSN Helpers].

The sender and data can be used safely when using `GSNRecipient` along with `_msgSender() and `_msgData()`.

Deciding how to approve and reject transactions is a bit more complex. The GSN recipient contract, by default, will accept and pay for all transactions. Chances are you probably want to choose which users can use your contracts via the GSN and potentially charge them for it, like a bouncer at a nightclub. We call these contracts _GSN Bouncers_.

We include `GSNBouncerSignature` and `GSNBouncerERC20Fee`, ready to use out of the box, along with how to create your own custom Bouncer.

== GSNBouncerSignature

The `GSNBouncerSignature` lets users call your recipient contract via the GSN (charging you for it) if they can prove that an account you trust approved them to do so. The way they do this is via a _signature_.

The transaction must be signed by the account that was added to the contract as a trusted signer. If it is not the same, this bouncer will not accept the transaction.

This means that you need to set up a system where your trusted account signs call requests, as long as they are valid users.

The definition of a valid user depends on your system, but an example is users that have completed their sign up via some kind of https://en.wikipedia.org/wiki/OAuth[OAuth] and validation, e.g., gone through a captcha or validated their email address.
You could restrict it further and let new users send a specific number of transactions (e.g. 5 requests via the GSN, at which point they need to create a wallet).
Alternatively, you could charge them off-chain (e.g. via credit card) for credit on your system and let them run GSN calls until their credit runs out.

The great thing about this setup is that *your contract doesn't need to change* if you want to change the business rules. All you are doing is changing the backend logic conditions under which users call into your contract for free.
On the other hand, you need to have a backend server, microservice, or lambda function to accomplish this.

=== How does GSNBouncerSignature work?

The definition of `acceptRelayedCall` function is below.  The function decides whether or not to accept the call based on the signature. No further GSN actions need to be taken.  The function only relies on the `approvalData`.

[source,solidity]
----
function acceptRelayedCall(
      address relay,
      address from,
      bytes calldata encodedFunction,
      uint256 transactionFee,
      uint256 gasPrice,
      uint256 gasLimit,
      uint256 nonce,
      bytes calldata approvalData,
      uint256
  )
      external
      view
      returns (uint256, bytes memory)
  {
      bytes memory blob = abi.encodePacked(
          relay,
          from,
          encodedFunction,
          transactionFee,
          gasPrice,
          gasLimit,
          nonce, // Prevents replays on RelayHub
          getHubAddr(), // Prevents replays in multiple RelayHubs
          address(this) // Prevents replays in multiple recipients
      );
      if (keccak256(blob).toEthSignedMessageHash().recover(approvalData) == _trustedSigner) {
          return _approveRelayedCall();
      } else {
          return _rejectRelayedCall(uint256(GSNRecipientSignedDataErrorCodes.INVALID_SIGNER));
      }
  }
----

==== Approve/Reject

When the signatures match, the function returns the following:

[source,solidity]
----

  return _approveRelayedCall();

  // Defined on base class GSNBouncerBase
  // uint256 constant private RELAYED_CALL_ACCEPTED = 0;
  // function _approveRelayedCall(bytes memory context) internal pure returns (uint256, bytes memory) {
  //    return (RELAYED_CALL_ACCEPTED, context);
  // }
----

On the other hand, when the signatures don't match, the call gets rejected with the following:

[source,solidity]
----

  return _rejectRelayedCall(uint256(GSNBouncerSignatureErrorCodes.INVALID_SIGNER));

  // Defined on base class GSNBouncerBase
  // uint256 constant private RELAYED_CALL_REJECTED = 11;
  // function _rejectRelayedCall(uint256 errorCode) internal pure returns (uint256, bytes memory) {
  //    return (RELAYED_CALL_REJECTED + errorCode, "");
  // }
----


=== How to use GSNBouncerSignature

Create your contract inheriting from `GSNRecipient` and `GSNBouncerSignature`, as well as setting the trusted signer in the constructor of `GSNBouncerSignature` as per the following sample code:

[source,solidity]
----
contract MyContract is GSNRecipient, GSNBouncerSignature {
    constructor(address trustedSigner) public GSNBouncerSignature(trustedSigner) {
    }
}  
----

== GSNBouncerERC20Fee

The `GSNBouncerERC20Fee` is a bit more complex (but don't worry, it has already been written for you!). Unlike `GSNBouncerSignature`, the `GSNBouncerERC20Fee` doesn't require any off-chain services.
Instead of off-chain approving the user for each transaction, you will give ERC20 tokens to your users. These tokens are then used to pay for GSN calls to your recipient contract.
Any user that has enough tokens is automatically approved and the recipient contract will cover their transaction costs!

This bouncer charges users for the ether cost your recipient will incur. Each recipient contract has their own unique token, with a baked-in exchange rate of 1:1 to ether, since they act as an ether replacement when using the GSN.

The `GSNBouncerSignature` has an internal mint function. Firstly, you need to setup a way to call it (e.g. add a public function with `onlyMinter` or some other form of xref:access-control.adoc[access control]).
Then, issue tokens to users based on your business logic. For example, you could mint a limited amount of tokens to new users, mint tokens when they buy them off-chain, give tokens based on the user subscription, etc.

NOTE: *Users do not need call approve* on their tokens for your recipient to use them. They are a modified ERC20 variant that lets the recipient contract retrieve them.

=== How does GSNBouncerERC20Fee work?

Let's look at how the `GSNBouncerERC20Fee` decides to approve or reject transactions.

[source,solidity]
----
function acceptRelayedCall(
    address,
    address from,
    bytes calldata,
    uint256 transactionFee,
    uint256 gasPrice,
    uint256,
    uint256,
    bytes calldata,
    uint256 maxPossibleCharge
)
    external
    view
    returns (uint256, bytes memory)
{
    if (_token.balanceOf(from) < maxPossibleCharge) {
        return _rejectRelayedCall(uint256(GSNBouncerERC20FeeErrorCodes.INSUFFICIENT_BALANCE));
    } else if (_token.allowance(from, address(this)) < maxPossibleCharge) {
        return _rejectRelayedCall(uint256(GSNBouncerERC20FeeErrorCodes.INSUFFICIENT_ALLOWANCE));
    }

    return _approveRelayedCall(abi.encode(from, maxPossibleCharge, transactionFee, gasPrice));
}
----

The bouncer rejects the transaction if the real sender doesn't have enough tokens or the recipient is not allowed to spend that amount of tokens.
If the sender can spend the required amount of tokens, the bouncer approves the transaction and returns `_approveRelayedCall` to make that data available to `_preRelayedCall` and `_postRelayedCall`.

Now, let's see how the token transfer is performed inside the `_preRelayedCall` function.

[source,solidity]
----
function _preRelayedCall(bytes memory context) internal returns (bytes32) {
    (address from, uint256 maxPossibleCharge) = abi.decode(context, (address, uint256));

    // The maximum token charge is pre-charged from the user
    _token.safeTransferFrom(from, address(this), maxPossibleCharge);
}
----

The maximum amount of tokens required is transferred assuming that the call will use all the gas available.
Then, in the `_postRelayedCall` function, the actual amount is calculated - including the implementation and ERC20 token transfers - and refund the difference.

[source,solidity]
----
function _postRelayedCall(bytes memory context, bool, uint256 actualCharge, bytes32) internal {
    (address from, uint256 maxPossibleCharge, uint256 transactionFee, uint256 gasPrice) =
        abi.decode(context, (address, uint256, uint256, uint256));

    // actualCharge is an _estimated_ charge, which assumes postRelayedCall will use all available gas.
    // This implementation's gas cost can be roughly estimated as 10k gas, for the two SSTORE operations in an
    // ERC20 transfer.
    uint256 overestimation = _computeCharge(POST_RELAYED_CALL_MAX_GAS.sub(10000), gasPrice, transactionFee);
    actualCharge = actualCharge.sub(overestimation);

    // After the relayed call has been executed and the actual charge estimated, the excess pre-charge is returned
    _token.safeTransfer(from, maxPossibleCharge.sub(actualCharge));
}
----

This is required to protect the contract from exploits (this is really similar to how ether is locked in Ethereum transactions).

NOTE: The gas cost estimation is not 100% accurate, we may tweak it further down the road.

NOTE: `_preRelayedCall` and `_postRelayedCall` are used instead of `preRelayedCall` and `postRelayedCall`. This prevents them from being called by non-relayhub. Always use `_preRelayedCall` and `_postRelayedCall` functions.

=== How to use GSNBouncerERC20Fee

Create your contract inheriting from `GSNRecipient` and `GSNBouncerERC20Fee` along with any xref:access-control.adoc[access control], set the token details in the constructor of `GSNBouncerERC20Fee` and create a public `mint` function suitably protected by your chosen access control as per the following sample code (which uses the https://docs.openzeppelin.com/contracts/2.x/api/access#MinterRole[MinterRole]):

[source,solidity]
----
contract MyContract is GSNRecipient, GSNBouncerERC20Fee, MinterRole {
    constructor() public GSNBouncerERC20Fee("FeeToken", "FEE", 18) {
    }

    function mint(address account, uint256 amount) public onlyMinter {
        _mint(account, amount);
    }
}
----

== Create your custom Bouncer [optional, for power users]

You can use `GSNBouncerBase` as an example to guide your Bouncer implementation.

The only thing you must do is extend from `GSNRecipient` and implement the `accept` function.

Depending on your logic, you may need to implement `_postRelayedCall` and `_preRelayedCall`.
